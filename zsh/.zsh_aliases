# reload zsh
alias zr='source ~/.config/zsh/.zshrc'

# update qutebrowser
alias qbup='sudo /opt/qutebrowser/scripts/mkvenv.py --update --pyqt-type link'

# dot aliases
alias ..='cd ..'
alias ...='cd ../..'
alias ....='cd ../../..'
alias .....='cd ../../../..'
alias ......='cd ../../../../..'
alias .......='cd ../../../../../..'

# ls aliases
alias ls='ls -F --color=auto'
alias ll='ls -lhA'
alias la='ls -hA'

# rm alias (function) to always ask for permission
rm() {
  if [[ $# -eq 0 ]]; then
    command rm
    return
  fi
  
  # Collect non-flag arguments that actually exist with indicators
  local files=()
  for arg in "$@"; do
    if [[ "$arg" != -* ]]; then
      if [[ -L "$arg" ]]; then
        # Symlink (including broken ones)
        files+=("'${arg}@'")
      elif [[ -d "$arg" ]]; then
        # Directory
        files+=("'${arg}/'")
      elif [[ -p "$arg" ]]; then
        # Named pipe (FIFO)
        files+=("'${arg}|'")
      elif [[ -S "$arg" ]]; then
        # Socket
        files+=("'${arg}='")
      elif [[ -b "$arg" || -c "$arg" ]]; then
        # Block or character device
        files+=("'${arg}#'")
      elif [[ -e "$arg" ]]; then
        # Regular file
        files+=("'${arg}'")
      fi
    fi
  done
  
  # If no actual files exist, just run rm to get the proper error message
  if [[ ${#files[@]} -eq 0 ]]; then
    command rm "$@"
    return
  fi
  
  echo -n "rm: remove ${files[@]}? [yn] "
  read -q && echo && command rm "$@" || echo
}

# enable/disable keyd
alias kdon="sudo systemctl enable --now keyd "
alias kdoff="sudo systemctl disable --now keyd "

# change keyboard layout
alias kles="setxkbmap es"
alias klus="setxkbmap us"
alias klq="setxkbmap -query"

# dir aliases
alias dir='dir --color=auto'
alias vdir='vdir --color=auto'

# grep aliases
alias grep='grep --color=auto'
alias fgrep='fgrep --color=auto'
alias egrep='egrep --color=auto'
    
# matlab package manager
alias mpm="/opt/mpm"

# neovim alias
alias nv='nvim'

# lazygit alias
alias lg='lazygit'

# R
alias r='R --silent --no-save'

# python
alias py='python3'
alias pipup="python3 -m pip list --outdated --format=json | jq -r '.[] | \"\(.name)==\(.latest_version)\"' | xargs -n1 pip3 install -U"

# julia
alias jl='julia'

# qstat alias for metacentrum
alias qs='ssh -o RemoteCommand=none meta qstat -u urtzien'
alias qs2='ssh -o RemoteCommand=none perian qstat -u urtzien'

# image viewer
alias iv='imv-x11'

# alias for ranger 
alias ra='ranger'

# alias for bat
alias bt='bat -p'

# fd as fdfind (in Debian it is called just with fdfind)
alias fd='fdfind'

#########
# fzf 

# sf: search files in given path (or current path if not specified), open appropriately
sf() {
  local search_path="${1:-.}"
  local file
  file=$(fd . "$search_path" \
    -HI \
    --type f \
    --exclude node_modules \
    --exclude .git \
    --exclude "$HOME/go" | \
    fzf-tmux --reverse --info=right -p 85%,85% --preview 'bat -p --color=always {} 2>/dev/null') || return

  local mime
  mime=$(file -b --mime-type "$file")

  if [[ $mime == text/html ]]; then
    qutebrowser --qt-arg class web --qt-arg name web "$file" &
  elif [[ $mime == text/* || $mime == application/javascript ]]; then
    nvim "$file"
  elif [[ -x "$file" ]]; then
    gio open "$file"
  elif [[ $mime == video/* ]]; then
    mpv "$file"
  else
    gio open "$file"
  fi
}

# sd: search dirs in given path (or current path if not specified), and cd appropriately
sd() {
  local search_path="${1:-.}"
  local dir
  dir=$(fd . "$search_path" \
    -HI \
    --type d \
    --exclude node_modules \
    --exclude .git \
    --exclude "$HOME/go" | \
    fzf-tmux --reverse --info=right -p 85%,85%) || return

  cd "$dir"
}

# sx: search files and dirs in given path (or current path if not specified), and cd appropriately
sx() {
  local search_path="${1:-.}"
  local selected
  selected=$(fd . "$search_path" \
    -HI \
    --type f --type d \
    --exclude node_modules \
    --exclude .git \
    --exclude "$HOME/go" | \
    fzf-tmux --reverse --info=right -p 85%,85% --preview 'bat -p --color=always {} 2>/dev/null') || return

  if [[ -d "$selected" ]]; then
    cd "$selected"
  else
    cd "$(dirname "$selected")"
  fi
}

# sfr: like sf but searches the whole system with locate
sfr() {
  local file
  file=$(locate / | while read -r f; do [[ -f "$f" ]] && echo "$f"; done | \
    fzf-tmux --reverse --info=right -p 85%,85% --preview 'bat -p --color=always {} 2>/dev/null') || return

  local mime
  mime=$(file -b --mime-type "$file")

  if [[ $mime == text/html ]]; then
    qutebrowser --qt-arg class web --qt-arg name web "$file" &
  elif [[ $mime == text/* || $mime == application/javascript ]]; then
    nvim "$file"
  elif [[ -x "$file" ]]; then
    gio open "$file"
  elif [[ $mime == video/* ]]; then
    mpv "$file"
  else
    gio open "$file"
  fi
}

# sdr: like sd but searches entire system using locate, and cd accordingly
sdr() {
  local dir
  dir=$(locate / | while read -r p; do
      [[ -d "$p" ]] && printf '%s\n' "$p"
    done | fzf-tmux --reverse --info=right -p 85%,85%) || return

  cd "$dir"
}

# sxr: like sx but searches entire system using locate, and cd accordingly
sxr() {
  local selected
  selected=$(locate / | fzf-tmux --reverse --info=right -p 85%,85% --preview 'bat -p --color=always {} 2>/dev/null') || return

  if [[ -d "$selected" ]]; then
    cd "$selected"
  else
    cd "$(dirname "$selected")"
  fi
}

# tmux with session name = term name
tm() {
	  tty_id=$(basename "$(tty)")
	  session="term_${tty_id}"
	  tmux new-session -A -s "$session"
}
