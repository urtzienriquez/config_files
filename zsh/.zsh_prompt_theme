# -------------------------------
# Load async library
# -------------------------------
source ~/.config/zsh/plugins/zsh-async/async.zsh

# -------------------------------
# Async prompt setup
# -------------------------------
setopt prompt_subst

# Cache variables
typeset -g _git_prompt_data=""
typeset -g _git_prompt_pwd=""
typeset -g _git_async_init=0

# -------------------------------
# Async worker function (does all git work)
# -------------------------------
_git_prompt_async_compute() {
    local work_dir="$1"
    cd "$work_dir" 2>/dev/null || return 1
    
    # Check if in git repo
    git rev-parse --is-inside-work-tree &>/dev/null || return 1
    
    local output=""
    
    # Get branch name
    local branch
    branch=$(git symbolic-ref --short HEAD 2>/dev/null)
    if [[ -z "$branch" ]]; then
        branch=$(git rev-parse --short HEAD 2>/dev/null)
    fi
    
    [[ -z "$branch" ]] && return 1
    
    # Check if in special state (rebase, merge, etc)
    local git_dir action=""
    git_dir=$(git rev-parse --git-dir 2>/dev/null)
    
    if [[ -d "$git_dir/rebase-merge" ]] || [[ -d "$git_dir/rebase-apply" ]]; then
        action="|REBASE"
    elif [[ -f "$git_dir/MERGE_HEAD" ]]; then
        action="|MERGE"
    elif [[ -f "$git_dir/CHERRY_PICK_HEAD" ]]; then
        action="|CHERRY-PICK"
    elif [[ -f "$git_dir/REVERT_HEAD" ]]; then
        action="|REVERT"
    elif [[ -f "$git_dir/BISECT_LOG" ]]; then
        action="|BISECT"
    fi
    
    # Start building output
    output=" %F{magenta} ${branch}%f"
    [[ -n "$action" ]] && output="${output}%F{yellow}${action}%f"
    
    # Get diff stats
    local stats_output added removed
    stats_output=$(git diff --numstat HEAD 2>/dev/null)
    added=0
    removed=0
    
    if [[ -n "$stats_output" ]]; then
        while IFS=$'\t' read -r add del file; do
            if [[ "$add" =~ ^[0-9]+$ ]]; then
                added=$((added + add))
            fi
            if [[ "$del" =~ ^[0-9]+$ ]]; then
                removed=$((removed + del))
            fi
        done <<< "$stats_output"
    fi
    
    # Get untracked files
    local untracked
    untracked=$(git ls-files --others --exclude-standard 2>/dev/null | wc -l)
    
    # Add stats to output
    [[ $added -gt 0 ]] && output="${output} %F{green}+${added}%f"
    [[ $removed -gt 0 ]] && output="${output} %F{red}-${removed}%f"
    [[ $untracked -gt 0 ]] && output="${output} %F{white}+${untracked}?%f"
    
    # Check if behind upstream
    local behind
    behind=$(git rev-list HEAD..@{upstream} 2>/dev/null | wc -l)
    [[ $behind -gt 0 ]] && output="${output} %F{yellow}↓${behind}%f"
    
    printf "%s" "$output"
}

# -------------------------------
# Async callback
# -------------------------------
_git_prompt_callback() {
    local job=$1
    local return_code=$2
    local stdout=$3
    
    # Only update if job succeeded and returned data
    if [[ $return_code -eq 0 ]] && [[ -n "$stdout" ]]; then
        _git_prompt_data="$stdout"
    else
        _git_prompt_data=""
    fi
    
    # Redraw prompt
    zle && zle reset-prompt
}

# -------------------------------
# Initialize async worker
# -------------------------------
_git_async_init_worker() {
    if [[ $_git_async_init -eq 0 ]]; then
        async_start_worker git_prompt_worker -n
        async_register_callback git_prompt_worker _git_prompt_callback
        _git_async_init=1
    fi
}

# -------------------------------
# Precmd hook to trigger async job
# -------------------------------
_git_prompt_precmd() {
    # Initialize worker on first run
    [[ $_git_async_init -eq 0 ]] && _git_async_init_worker
    
    # Quick check if in git repo (fast operation)
    if ! git rev-parse --is-inside-work-tree &>/dev/null; then
        _git_prompt_data=""
        _git_prompt_pwd=""
        return
    fi
    
    # Always trigger async job when in git repo
    # This ensures git info updates after every command
    _git_prompt_pwd="$PWD"
    
    # Flush any pending jobs
    async_flush_jobs git_prompt_worker 2>/dev/null
    
    # Start new async job
    async_job git_prompt_worker _git_prompt_async_compute "$PWD"
}

# Add to precmd
autoload -Uz add-zsh-hook
add-zsh-hook precmd _git_prompt_precmd

# -------------------------------
# Also trigger on directory change
# -------------------------------
_git_prompt_chpwd() {
    # Reset pwd to force refresh
    _git_prompt_pwd=""
}
add-zsh-hook chpwd _git_prompt_chpwd

# -------------------------------
# Auto-fetch when entering a git repo (optional, runs in background)
# -------------------------------
chpwd_git_fetch() {
    if git rev-parse --is-inside-work-tree &>/dev/null; then
        {
            git fetch --quiet 2>/dev/null
            # Trigger async update after fetch
            async_flush_jobs git_prompt_worker 2>/dev/null
            async_job git_prompt_worker _git_prompt_async_compute "$PWD"
        } &!
    fi
}
add-zsh-hook chpwd chpwd_git_fetch

# -------------------------------
# Manual refresh function
# -------------------------------
grefresh() {
    _git_prompt_pwd=""
    _git_prompt_data=""
    if [[ $_git_async_init -eq 1 ]]; then
        async_flush_jobs git_prompt_worker 2>/dev/null
        if git rev-parse --is-inside-work-tree &>/dev/null; then
            async_job git_prompt_worker _git_prompt_async_compute "$PWD"
        fi
    fi
}

# -------------------------------
# Vi mode indicator
# -------------------------------
function zle-line-init zle-keymap-select {
    VI_MODE_SYMBOL="${${KEYMAP/vicmd/}/(main|viins)/}"
    zle reset-prompt
}
zle -N zle-line-init
zle -N zle-keymap-select

# -------------------------------
# Custom prompt
# -------------------------------
PROMPT='%F{magenta}%n@%m%f %F{cyan}%~%f${_git_prompt_data}
%F{%(?.green.red)}${VI_MODE_SYMBOL}%f '

# -------------------------------
# Initialize on load
# -------------------------------
async_init
